#include "ros/ros.h"
#include "std_msgs/String.h"
#include "std_msgs/Int32.h"
#include <sstream>
#include <image_transport/image_transport.h>
#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/bgsegm.hpp>

#include <libvibe++/ViBe.h>
#include <libvibe++/distances/Manhattan.h>
#include <libvibe++/system/types.h>

using namespace std;
using namespace cv;
using namespace ViBe;

/* Parameterization of ViBe. */
typedef ViBeSequential<1, Manhattan<1> > ViBeasdf;
ViBeasdf* vibe = NULL;
bool firstFrame = true;
int height = 0;
int width = 0;
cv::Mat output, processedOutput, finalIm, dilatedIm, erodedIm;
cv::Mat *segmentationMap;
int frame_ctr = 0;
//Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
/*bool firstFrame = true;
int height = 540;
int width = 960 ;
cv::Mat output, processedOutput, finalIm, dilatedIm, erodedIm;
ViBeasdf* vibe = NULL;
cv::Mat segmentationMap(height, width, CV_8UC1);
*/
void find_bird(cv::Mat frame)
{
   // pMOG2 = createBackgroundSubtractorMOG2();

//cout<<"I am here"<<endl;
   // cv::imshow("Original Frame",frame);



   if (firstFrame)
    {
       height = frame.size().height;
        width = frame.size().width;
        segmentationMap = new Mat(height, width, CV_8UC1);


        /* Instantiation of ViBe. */
        vibe = new ViBeasdf(frame.size().height, frame.size().width, frame.data);
        firstFrame = false;
    }



/*    cout<<"Height"<<frame.size().height<<endl;
    cout<<"Width"<<frame.size().width<<endl;*/

    //pMOG2->apply(frame, fgMaskMOG2);

    vibe->segmentation(frame.data, segmentationMap->data);
    vibe->update(frame.data, segmentationMap->data);

    medianBlur(*segmentationMap, processedOutput, 3);
    //medianBlur(pMOG2, processedOutput, 3);
    erode(processedOutput,erodedIm , 0, Point(-1, -1), 2, 1, 1);
    dilate(erodedIm,dilatedIm , 0, Point(-1, -1), 2, 1, 1);

    int num_of_countours = 0;
    float largest_area = 0.0;
    Rect bounding_rect;
    vector<vector<Point> > contours; // Vector for storing contour
    vector<Vec4i> hierarchy;
    findContours(dilatedIm, contours, hierarchy,CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE );
    // iterate through each contour.
    for( int i = 0; i< contours.size(); i++)
    {
        //  Find the area of contour
        double a = cv::contourArea( contours[i],false); 

        // Find the bounding rectangle for biggest contour
        bounding_rect=boundingRect(contours[i]);
        rectangle(frame, bounding_rect,  Scalar(0,0,255),2, 8,0);

/*        cout <<"Number of Birds"<<num_of_countours<<endl;
        int b = getTickCount();
        int c = b-a;
        cout<<"tick count"<<c<<endl;*/


    }
    cout<<contours.size()<<endl;
    if (frame_ctr > 1365)

    {
        ostringstream file, file2;
        file << "vibeimage" << frame_ctr << ".png";
        file2 << "vibeimagemask" << frame_ctr << ".png";
        imwrite(file.str(), frame);
        imwrite(file2.str(), dilatedIm);

    }

    


    
    //Draw the contour and rectangle
    //rectangle(frame, bounding_rect,  Scalar(0,0,255),0.8, 8,0);

    //imshow("Split_View", frame);
    //imshow("dilated", dilatedIm);
    //imshow("ViBe", *segmentationMap);
    //imshow("medianBlur",processedOutput);
    //imshow("Erode", erodedIm);
    //imshow("Dilate", dilatedIm);


    cvWaitKey(1);
}


void imageCallback(const sensor_msgs::ImageConstPtr& msg)
{
	try
{


 find_bird(cv_bridge::toCvShare(msg, "mono8")->image);

}


catch (cv_bridge::Exception& e)
{
	ROS_ERROR("Not found image");
}

}
void frame_numCallback (const std_msgs::Int32 message)
{
    frame_ctr = message.data;
}

int main(int argc, char  **argv)
{
	ros::init(argc, argv, "image_listener", ros::init_options::AnonymousName);
	ros::NodeHandle nh;
    int frame_number;
	//cv::namedWindow("Split_View");
	cv::startWindowThread();
    ros::param::get("~frame_number", frame_number);
	image_transport::ImageTransport it(nh);

    std::string topic_name;
    if (frame_number == 0)
        topic_name = "/image_raw/frame_0";
    else if (frame_number == 1)
        topic_name = "/image_raw/frame_1";
    else if (frame_number == 2)
        topic_name = "/image_raw/frame_2";
    else if (frame_number == 3)
        topic_name = "/image_raw/frame_3";
	image_transport::Subscriber sub = it.subscribe(topic_name, 1, imageCallback);
    ros::Subscriber sub2 = nh.subscribe("frame_num", 1000, frame_numCallback);


	//video_sub = it_.subscribe("/image_raw/frame1", 1, &VisionSensor::receive_image_cb, this);
	ros::spin();
	//cv::destroyWindow("view2");

}

